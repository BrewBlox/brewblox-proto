syntax = "proto3";

import "brewblox.proto";
import "nanopb.proto";
import "IoArray.proto";

package blox;

// pin options
// 0: unused (x)
// 1: always GND (gnd)
// 2: always PWR (pwr)
// 3: pull up (pu)
// 4: pull down (pd)
// 5: push/pull (pp)
// 6: passsive open load detect only (old)

enum GpioDeviceType {
  NONE = 0;
  TWO_PIN_SSR = 1;                     // gnd, pp
  ONE_PIN_SSR = 2;                     // pp, external ground
  SINGLE_PIN_COIL_TO_EXTERNAL_GND = 3; // pu, external ground
  SINGLE_PIN_COIL_TO_EXTERNAL_PWR = 4; // pd, external ground
  TWO_PIN_COIL = 5;                    // gnd, pu
  TWO_PIN_COIL_PUSH_PULL = 6;          // pp,pp toggled 01 or 10
  TWO_PIN_MOTOR_UNIDIRECTIONAL = 7;    // gnd, pp
  SINGLE_PIN_MOTOR_HIGH_SIDE = 8;      // pu, external to GND
  SINGLE_PIN_MOTOR_LOW_SIDE = 9;       // pd, external to PWR
  TWO_PIN_MOTOR_BIDIRECTIONAL = 10;    // pp, pp, toggle 01 or 10
  TWO_PIN_SWITCH_INPUT = 11;           // old, old
  SWITCH_TO_EXTERNAL_GND = 12;         // old, external GND
  SWITCH_TO_PWR = 13;                  // old, external PWR
  POWERED_SWITCH_TO_EXTERNAL_GND = 14; // pwr, with load detect
  POWERED_SWITCH_TO_EXTERNAL_PWR = 15; // gnd, with load detect
};

enum ChannelStatus {
  UNKNOWN = 0;
  OPERATIONAL = 1;
  OVERCURRENT = 2;
  OPEN_LOAD = 3;
  UNDERVOLTAGE = 4;
  OVERVOLTAGE = 5;
  OVERTEMPERATURE_SHUTDOWN = 6;
  OVERTEMPERATURE_WARNING = 7;
  POWER_ON_RESET = 8;
  SPI_ERROR = 9;
};

// Each channel has a bitmask for which pins it uses.
// These bit positions correspond to global fiels in the module and are non-overlapping between channels.
// The number of ones can be multiples of the number of pins (1 or 2) above
// Examples:
// SSR on pin 3 and 4, pins_mask: 0000001100
// 2A bidirectional motor between pin 1,2 and 3,4: pins_mask: 00001111, will switch 0000, 1100 or 0011

message GpioModuleChannel {
  uint32 id = 1 [ (nanopb).int_size = IS_8 ];
  GpioDeviceType deviceType = 2;
  uint32 pinsMask = 3 [ (nanopb).int_size = IS_8, (brewblox).bitfield = true ];
  ChannelStatus status = 4 [ (brewblox).readonly = true ];
  ChannelConfig config = 5 [ (brewblox).readonly = true ];
  DigitalState state = 6 [ (brewblox).readonly = true ];
  int32 pwmDuty = 7 [ (brewblox).readonly = true, (nanopb).int_size = IS_16 ];
}

message OneWireGpioModule {
  option (brewblox_msg).objtype = OneWireGpioModule;
  option (brewblox_msg).impl = IoArrayInterface;
  option (brewblox_msg).impl = OneWireBusInterface;

  repeated GpioModuleChannel channels = 1 [ (nanopb).max_count = 8 ];
  uint32 modulePosition = 2 [ (nanopb).int_size = IS_8 ];
  // 7 reserved | 6 overtemperature shutdown | 5 overtemperature warning | 4 open load | 3 overcurrent | 2 undervoltage lockout | 1 overvoltage | 0 power-on-reset
  uint32 moduleStatus = 3 [ (nanopb).int_size = IS_8, (brewblox).bitfield = true ];
  uint32 pullUp = 4 [ (brewblox).readonly = true, (nanopb).int_size = IS_8, (brewblox).bitfield = true ];
  uint32 pullUpWhenActive = 5 [ (brewblox).readonly = true, (nanopb).int_size = IS_8, (brewblox).bitfield = true ];
  uint32 pullUpWhenInactive = 6 [ (brewblox).readonly = true, (nanopb).int_size = IS_8, (brewblox).bitfield = true ];
  uint32 pullDown = 7 [ (brewblox).readonly = true, (nanopb).int_size = IS_8, (brewblox).bitfield = true ];
  uint32 pullDownWhenActive = 8 [ (brewblox).readonly = true, (nanopb).int_size = IS_8, (brewblox).bitfield = true ];
  uint32 pullDownWhenInactive = 9 [ (brewblox).readonly = true, (nanopb).int_size = IS_8, (brewblox).bitfield = true ];
  uint32 pullUpOverCurrent = 10 [ (brewblox).readonly = true, (nanopb).int_size = IS_8, (brewblox).bitfield = true ];
  uint32 pullDownOverCurrent = 11 [ (brewblox).readonly = true, (nanopb).int_size = IS_8, (brewblox).bitfield = true ];
  uint32 pullUpOpenLoad = 12 [ (brewblox).readonly = true, (nanopb).int_size = IS_8, (brewblox).bitfield = true ];
  uint32 pullDownOpenLoad = 13 [ (brewblox).readonly = true, (nanopb).int_size = IS_8, (brewblox).bitfield = true ];
  // write a 1 to clear a status flag and re-enable channels in shutdown, always reads as zero
  uint32 moduleStatusClear = 14 [ (nanopb).int_size = IS_8, (brewblox).bitfield = true ];
}
