syntax = "proto3";

import "brewblox.proto";
import "nanopb.proto";
import "IoArray.proto";

package blox;

// pin options
// 0: unused (x)
// 1: always GND (gnd)
// 2: always PWR (pwr)
// 3: pull up (pu)
// 4: pull down (pd)
// 5: push/pull (pp)
// 6: passsive open load detect only (old)

enum GpioDeviceType {
  GPIO_DEV_NONE = 0;
  GPIO_DEV_SSR_2P = 1;                    // gnd, pp
  GPIO_DEV_SSR_1P = 2;                    // pp, external ground
  GPIO_DEV_COIL_UNIDIRECTIONAL_2P = 3;    // gnd, pu
  GPIO_DEV_COIL_BIDIRECTIONAL_2P = 4;     // pp,pp toggled 01 or 10
  GPIO_DEV_COIL_HIGH_SIDE_1P = 5;         // pu, external ground
  GPIO_DEV_COIL_LOW_SIDE_1P = 6;          // pd, external ground
  GPIO_DEV_MOTOR_UNIDIRECTIONAL_2P = 7;   // gnd, pp
  GPIO_DEV_MOTOR_BIDIRECTIONAL_2P = 8;    // pp, pp, toggle 01 or 10
  GPIO_DEV_MOTOR_HIGH_SIDE_1P = 9;        // pu, external to GND
  GPIO_DEV_MOTOR_LOW_SIDE_1P = 10;        // pd, external to PWR
  GPIO_DEV_LOAD_DETECT_2P = 11;           // old, old
  GPIO_DEV_LOAD_DETECT_PULL_DOWN_1P = 12; // old, external GND
  GPIO_DEV_LOAD_DETECT_PULL_UP_1P = 13;   // old, external PWR
  GPIO_DEV_POWER_LOAD_DETECT_1P = 14;     // pwr, with load detect
  GPIO_DEV_GND_LOAD_DETECT_1P = 15;       // gnd, with load detect
  GPIO_DEV_POWER_1P = 16;                 // pwr, without load detect
  GPIO_DEV_GND_1P = 17;                   // gnd, without load detect
};

// Error flags
enum GpioErrorFlags {
  GPIO_ERR_NONE = 0;
  GPIO_ERR_POWER_ON_RESET = 1;
  GPIO_ERR_OVERVOLTAGE = 2;
  GPIO_ERR_UNDERVOLTAGE = 4;
  GPIO_ERR_OVERCURRENT = 8;
  GPIO_ERR_OPEN_LOAD = 16;
  GPIO_ERR_OVERTEMPERATURE_WARNING = 32;
  GPIO_ERR_OVERTEMPERATURE_ERROR = 64;
  GPIO_ERR_SPI_ERROR = 128;
};

// Each channel has a bitmask for which pins it uses.
// These bit positions correspond to global fiels in the module and are non-overlapping between channels.
// The number of ones can be multiples of the number of pins (1 or 2) above
// Examples:
// SSR on pin 3 and 4, pins_mask: 0000001100
// 2A bidirectional motor between pin 1,2 and 3,4: pins_mask: 00001111, will switch 0000, 1100 or 0011

message GpioModuleChannel {
  uint32 id = 1 [ (nanopb).int_size = IS_8 ];
  GpioDeviceType deviceType = 2;
  uint32 pinsMask = 3 [ (nanopb).int_size = IS_8, (brewblox).bitfield = true ];
  ChannelConfig config = 5 [ (brewblox).readonly = true ];
  DigitalState state = 6 [ (brewblox).readonly = true ];
  int32 pwmDuty = 7 [ (brewblox).readonly = true, (nanopb).int_size = IS_16 ];
}

message OneWireGpioModule {
  option (brewblox_msg).objtype = OneWireGpioModule;
  option (brewblox_msg).impl = IoArrayInterface;
  option (brewblox_msg).impl = OneWireBusInterface;

  repeated GpioModuleChannel channels = 1 [ (nanopb).max_count = 8 ];
  uint32 modulePosition = 2 [ (nanopb).int_size = IS_8 ];
  // 7 reserved | 6 overtemperature shutdown | 5 overtemperature warning | 4 open load | 3 overcurrent | 2 undervoltage lockout | 1 overvoltage | 0 power-on-reset
  uint32 moduleStatus = 3 [ (nanopb).int_size = IS_8, (brewblox).bitfield = true ];
  uint32 pullUpDesired = 4 [ (brewblox).readonly = true, (nanopb).int_size = IS_8, (brewblox).bitfield = true ];
  uint32 pullUpStatus = 5 [ (brewblox).readonly = true, (nanopb).int_size = IS_8, (brewblox).bitfield = true ];
  uint32 pullUpWhenActive = 6 [ (brewblox).readonly = true, (nanopb).int_size = IS_8, (brewblox).bitfield = true ];
  uint32 pullUpWhenInactive = 7 [ (brewblox).readonly = true, (nanopb).int_size = IS_8, (brewblox).bitfield = true ];
  uint32 pullDownDesired = 8 [ (brewblox).readonly = true, (nanopb).int_size = IS_8, (brewblox).bitfield = true ];
  uint32 pullDownStatus = 9 [ (brewblox).readonly = true, (nanopb).int_size = IS_8, (brewblox).bitfield = true ];
  uint32 pullDownWhenActive = 10 [ (brewblox).readonly = true, (nanopb).int_size = IS_8, (brewblox).bitfield = true ];
  uint32 pullDownWhenInactive = 11 [ (brewblox).readonly = true, (nanopb).int_size = IS_8, (brewblox).bitfield = true ];
  uint32 overCurrent = 12 [ (brewblox).readonly = true, (nanopb).int_size = IS_8, (brewblox).bitfield = true ];
  uint32 openLoad = 13 [ (brewblox).readonly = true, (nanopb).int_size = IS_8, (brewblox).bitfield = true ];

  // write a 1 to clear a status flag and re-enable channels in shutdown, always reads as zero
  uint32 moduleStatusClear = 16 [ (nanopb).int_size = IS_8, (brewblox).bitfield = true ];
}
