syntax = "proto3";

import "brewblox.proto";
import "nanopb.proto";
import "IoArray.proto";

package blox;

message GpioChannel {
  enum Type {
    NONE = 0;
    INPUT = 1;
    OUTPUT = 2;
    OUTPUT_PWM_80HZ = 3;
    OUTPUT_PWM_100HZ = 4;
    OUTPUT_PWM_200HZ = 5;
    OUTPUT_PWM_2KHZ = 6;
  };

  uint32 id = 1 [ (nanopb).int_size = IS_8 ];
  ChannelConfig config = 2;
  Type type = 10;
  uint32 pins = 11 [ (nanopb).int_size = IS_16 ];
  uint32 when_active = 12 [ (nanopb).int_size = IS_16 ];
  uint32 when_inactive = 13 [ (nanopb).int_size = IS_16 ];
  uint32 pwm_duty = 14 [ (nanopb).int_size = IS_8 ];
};

message ExpOwGpio {
  option (brewblox_msg).objtype = ExpOwGpio;
  option (brewblox_msg).impl = IoArrayInterface;

  repeated GpioChannel channels = 1 [ (nanopb).max_count = 8 ];
  uint32 address = 2 [ (nanopb).int_size = IS_8 ];
  uint32 status = 7 [ (brewblox).readonly = true, (nanopb).int_size = IS_8 ]; // 7 reserved | 6 overtemperature | 5 overcurrent | 4 open load | 3 | overcurrent | 2 undervoltage lockout | 1 overvoltage | 0 power-on-reset
  uint32 drive = 8 [ (brewblox).readonly = true, (nanopb).int_size = IS_16 ];
  uint32 overcurrent = 9 [ (brewblox).readonly = true, (nanopb).int_size = IS_16 ];
  uint32 openload = 10 [ (brewblox).readonly = true, (nanopb).int_size = IS_16 ];
}
