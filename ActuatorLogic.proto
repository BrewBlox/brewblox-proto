syntax = "proto3";

import "brewblox.proto";
import "nanopb.proto";
import "IoArray.proto";
package blox;

message ActuatorLogic {
  option (brewblox_msg).objtype = ActuatorLogic;

  enum DigitalCompareOp {
    VALUE_IS = 0;
    VALUE_ISNOT = 1;
    DESIRED_IS = 2;
    DESIRED_ISNOT = 3;
  }

  enum AnalogCompareOp {
    VALUE_GE = 0;
    VALUE_LE = 1;
    SETTING_GE = 2;
    SETTING_LE = 3;
  }

  enum CombineOp {
    OR = 0;
    AND = 1;
    OR_NOT = 2;
    AND_NOT = 3;
    XOR = 4;
  };

  message DigitalCompare {
    DigitalCompareOp op = 1;
    uint32 id = 2 [
      (brewblox).objtype = ActuatorDigitalInterface,
      (nanopb).int_size = IS_16
    ];
    DigitalState rhs = 3;
  };

  message AnalogCompare {
    AnalogCompareOp op = 1;
    uint32 id = 2 [
      (brewblox).objtype = ProcessValueInterface,
      (nanopb).int_size = IS_16
    ];
    sint32 rhs = 3 [ (brewblox).scale = 4096, (nanopb).int_size = IS_32 ];
  };

  message Compare {
    CombineOp combineOp = 1;
    oneof compare {
      DigitalCompare digital = 2;
      AnalogCompare analog = 3;
    }
  }

  message Section {
    CombineOp combineOp = 1;
    repeated Compare compare = 2 [ (nanopb).max_count = 4 ];
  }

  uint32 targetId = 1 [
    (brewblox).objtype = ActuatorDigitalInterface,
    (nanopb).int_size = IS_16
  ];
  bool enabled = 2;
  bool result = 3 [ (brewblox).logged = true, (brewblox).readonly = true ];
  repeated Section section = 4 [ (nanopb).max_count = 6 ];
}
